// Code generated by ent, DO NOT EDIT.

package ent

import (
	"AtoiTalkAPI/ent/attachment"
	"AtoiTalkAPI/ent/chat"
	"AtoiTalkAPI/ent/groupchat"
	"AtoiTalkAPI/ent/groupmember"
	"AtoiTalkAPI/ent/message"
	"AtoiTalkAPI/ent/otp"
	"AtoiTalkAPI/ent/predicate"
	"AtoiTalkAPI/ent/privatechat"
	"AtoiTalkAPI/ent/user"
	"AtoiTalkAPI/ent/useridentity"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachment   = "Attachment"
	TypeChat         = "Chat"
	TypeGroupChat    = "GroupChat"
	TypeGroupMember  = "GroupMember"
	TypeMessage      = "Message"
	TypeOTP          = "OTP"
	TypePrivateChat  = "PrivateChat"
	TypeUser         = "User"
	TypeUserIdentity = "UserIdentity"
)

// AttachmentMutation represents an operation that mutates the Attachment nodes in the graph.
type AttachmentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	file_name      *string
	file_type      *attachment.FileType
	original_name  *string
	file_size      *int64
	addfile_size   *int64
	clearedFields  map[string]struct{}
	message        *int
	clearedmessage bool
	done           bool
	oldValue       func(context.Context) (*Attachment, error)
	predicates     []predicate.Attachment
}

var _ ent.Mutation = (*AttachmentMutation)(nil)

// attachmentOption allows management of the mutation configuration using functional options.
type attachmentOption func(*AttachmentMutation)

// newAttachmentMutation creates new mutation for the Attachment entity.
func newAttachmentMutation(c config, op Op, opts ...attachmentOption) *AttachmentMutation {
	m := &AttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentID sets the ID field of the mutation.
func withAttachmentID(id int) attachmentOption {
	return func(m *AttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Attachment
		)
		m.oldValue = func(ctx context.Context) (*Attachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachment sets the old Attachment of the mutation.
func withAttachment(node *Attachment) attachmentOption {
	return func(m *AttachmentMutation) {
		m.oldValue = func(context.Context) (*Attachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttachmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttachmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttachmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetMessageID sets the "message_id" field.
func (m *AttachmentMutation) SetMessageID(i int) {
	m.message = &i
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *AttachmentMutation) MessageID() (r int, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldMessageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ClearMessageID clears the value of the "message_id" field.
func (m *AttachmentMutation) ClearMessageID() {
	m.message = nil
	m.clearedFields[attachment.FieldMessageID] = struct{}{}
}

// MessageIDCleared returns if the "message_id" field was cleared in this mutation.
func (m *AttachmentMutation) MessageIDCleared() bool {
	_, ok := m.clearedFields[attachment.FieldMessageID]
	return ok
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *AttachmentMutation) ResetMessageID() {
	m.message = nil
	delete(m.clearedFields, attachment.FieldMessageID)
}

// SetFileName sets the "file_name" field.
func (m *AttachmentMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *AttachmentMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *AttachmentMutation) ResetFileName() {
	m.file_name = nil
}

// SetFileType sets the "file_type" field.
func (m *AttachmentMutation) SetFileType(at attachment.FileType) {
	m.file_type = &at
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *AttachmentMutation) FileType() (r attachment.FileType, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFileType(ctx context.Context) (v attachment.FileType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "file_type" field.
func (m *AttachmentMutation) ResetFileType() {
	m.file_type = nil
}

// SetOriginalName sets the "original_name" field.
func (m *AttachmentMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *AttachmentMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *AttachmentMutation) ResetOriginalName() {
	m.original_name = nil
}

// SetFileSize sets the "file_size" field.
func (m *AttachmentMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *AttachmentMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the Attachment entity.
// If the Attachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *AttachmentMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *AttachmentMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *AttachmentMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *AttachmentMutation) ClearMessage() {
	m.clearedmessage = true
	m.clearedFields[attachment.FieldMessageID] = struct{}{}
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *AttachmentMutation) MessageCleared() bool {
	return m.MessageIDCleared() || m.clearedmessage
}

// MessageIDs returns the "message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MessageID instead. It exists only for internal usage by the builders.
func (m *AttachmentMutation) MessageIDs() (ids []int) {
	if id := m.message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *AttachmentMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
}

// Where appends a list predicates to the AttachmentMutation builder.
func (m *AttachmentMutation) Where(ps ...predicate.Attachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attachment).
func (m *AttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, attachment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attachment.FieldUpdatedAt)
	}
	if m.message != nil {
		fields = append(fields, attachment.FieldMessageID)
	}
	if m.file_name != nil {
		fields = append(fields, attachment.FieldFileName)
	}
	if m.file_type != nil {
		fields = append(fields, attachment.FieldFileType)
	}
	if m.original_name != nil {
		fields = append(fields, attachment.FieldOriginalName)
	}
	if m.file_size != nil {
		fields = append(fields, attachment.FieldFileSize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.CreatedAt()
	case attachment.FieldUpdatedAt:
		return m.UpdatedAt()
	case attachment.FieldMessageID:
		return m.MessageID()
	case attachment.FieldFileName:
		return m.FileName()
	case attachment.FieldFileType:
		return m.FileType()
	case attachment.FieldOriginalName:
		return m.OriginalName()
	case attachment.FieldFileSize:
		return m.FileSize()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attachment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attachment.FieldMessageID:
		return m.OldMessageID(ctx)
	case attachment.FieldFileName:
		return m.OldFileName(ctx)
	case attachment.FieldFileType:
		return m.OldFileType(ctx)
	case attachment.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case attachment.FieldFileSize:
		return m.OldFileSize(ctx)
	}
	return nil, fmt.Errorf("unknown Attachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attachment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attachment.FieldMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case attachment.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case attachment.FieldFileType:
		v, ok := value.(attachment.FileType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case attachment.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case attachment.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, attachment.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attachment.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attachment.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown Attachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attachment.FieldMessageID) {
		fields = append(fields, attachment.FieldMessageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentMutation) ClearField(name string) error {
	switch name {
	case attachment.FieldMessageID:
		m.ClearMessageID()
		return nil
	}
	return fmt.Errorf("unknown Attachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentMutation) ResetField(name string) error {
	switch name {
	case attachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attachment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attachment.FieldMessageID:
		m.ResetMessageID()
		return nil
	case attachment.FieldFileName:
		m.ResetFileName()
		return nil
	case attachment.FieldFileType:
		m.ResetFileType()
		return nil
	case attachment.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case attachment.FieldFileSize:
		m.ResetFileSize()
		return nil
	}
	return fmt.Errorf("unknown Attachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.message != nil {
		edges = append(edges, attachment.EdgeMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachment.EdgeMessage:
		if id := m.message; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmessage {
		edges = append(edges, attachment.EdgeMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case attachment.EdgeMessage:
		return m.clearedmessage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentMutation) ClearEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ClearMessage()
		return nil
	}
	return fmt.Errorf("unknown Attachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentMutation) ResetEdge(name string) error {
	switch name {
	case attachment.EdgeMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown Attachment edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	_type               *chat.Type
	clearedFields       map[string]struct{}
	messages            map[int]struct{}
	removedmessages     map[int]struct{}
	clearedmessages     bool
	last_message        *int
	clearedlast_message bool
	private_chat        *int
	clearedprivate_chat bool
	group_chat          *int
	clearedgroup_chat   bool
	done                bool
	oldValue            func(context.Context) (*Chat, error)
	predicates          []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id int) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ChatMutation) SetType(c chat.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChatMutation) GetType() (r chat.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldType(ctx context.Context) (v chat.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChatMutation) ResetType() {
	m._type = nil
}

// SetLastMessageID sets the "last_message_id" field.
func (m *ChatMutation) SetLastMessageID(i int) {
	m.last_message = &i
}

// LastMessageID returns the value of the "last_message_id" field in the mutation.
func (m *ChatMutation) LastMessageID() (r int, exists bool) {
	v := m.last_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLastMessageID returns the old "last_message_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldLastMessageID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastMessageID: %w", err)
	}
	return oldValue.LastMessageID, nil
}

// ClearLastMessageID clears the value of the "last_message_id" field.
func (m *ChatMutation) ClearLastMessageID() {
	m.last_message = nil
	m.clearedFields[chat.FieldLastMessageID] = struct{}{}
}

// LastMessageIDCleared returns if the "last_message_id" field was cleared in this mutation.
func (m *ChatMutation) LastMessageIDCleared() bool {
	_, ok := m.clearedFields[chat.FieldLastMessageID]
	return ok
}

// ResetLastMessageID resets all changes to the "last_message_id" field.
func (m *ChatMutation) ResetLastMessageID() {
	m.last_message = nil
	delete(m.clearedFields, chat.FieldLastMessageID)
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *ChatMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *ChatMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *ChatMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *ChatMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *ChatMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ChatMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ChatMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// ClearLastMessage clears the "last_message" edge to the Message entity.
func (m *ChatMutation) ClearLastMessage() {
	m.clearedlast_message = true
	m.clearedFields[chat.FieldLastMessageID] = struct{}{}
}

// LastMessageCleared reports if the "last_message" edge to the Message entity was cleared.
func (m *ChatMutation) LastMessageCleared() bool {
	return m.LastMessageIDCleared() || m.clearedlast_message
}

// LastMessageIDs returns the "last_message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LastMessageID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) LastMessageIDs() (ids []int) {
	if id := m.last_message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLastMessage resets all changes to the "last_message" edge.
func (m *ChatMutation) ResetLastMessage() {
	m.last_message = nil
	m.clearedlast_message = false
}

// SetPrivateChatID sets the "private_chat" edge to the PrivateChat entity by id.
func (m *ChatMutation) SetPrivateChatID(id int) {
	m.private_chat = &id
}

// ClearPrivateChat clears the "private_chat" edge to the PrivateChat entity.
func (m *ChatMutation) ClearPrivateChat() {
	m.clearedprivate_chat = true
}

// PrivateChatCleared reports if the "private_chat" edge to the PrivateChat entity was cleared.
func (m *ChatMutation) PrivateChatCleared() bool {
	return m.clearedprivate_chat
}

// PrivateChatID returns the "private_chat" edge ID in the mutation.
func (m *ChatMutation) PrivateChatID() (id int, exists bool) {
	if m.private_chat != nil {
		return *m.private_chat, true
	}
	return
}

// PrivateChatIDs returns the "private_chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrivateChatID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) PrivateChatIDs() (ids []int) {
	if id := m.private_chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrivateChat resets all changes to the "private_chat" edge.
func (m *ChatMutation) ResetPrivateChat() {
	m.private_chat = nil
	m.clearedprivate_chat = false
}

// SetGroupChatID sets the "group_chat" edge to the GroupChat entity by id.
func (m *ChatMutation) SetGroupChatID(id int) {
	m.group_chat = &id
}

// ClearGroupChat clears the "group_chat" edge to the GroupChat entity.
func (m *ChatMutation) ClearGroupChat() {
	m.clearedgroup_chat = true
}

// GroupChatCleared reports if the "group_chat" edge to the GroupChat entity was cleared.
func (m *ChatMutation) GroupChatCleared() bool {
	return m.clearedgroup_chat
}

// GroupChatID returns the "group_chat" edge ID in the mutation.
func (m *ChatMutation) GroupChatID() (id int, exists bool) {
	if m.group_chat != nil {
		return *m.group_chat, true
	}
	return
}

// GroupChatIDs returns the "group_chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupChatID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) GroupChatIDs() (ids []int) {
	if id := m.group_chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupChat resets all changes to the "group_chat" edge.
func (m *ChatMutation) ResetGroupChat() {
	m.group_chat = nil
	m.clearedgroup_chat = false
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, chat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chat.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, chat.FieldType)
	}
	if m.last_message != nil {
		fields = append(fields, chat.FieldLastMessageID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldCreatedAt:
		return m.CreatedAt()
	case chat.FieldUpdatedAt:
		return m.UpdatedAt()
	case chat.FieldType:
		return m.GetType()
	case chat.FieldLastMessageID:
		return m.LastMessageID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case chat.FieldType:
		return m.OldType(ctx)
	case chat.FieldLastMessageID:
		return m.OldLastMessageID(ctx)
	}
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case chat.FieldType:
		v, ok := value.(chat.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case chat.FieldLastMessageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastMessageID(v)
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chat.FieldLastMessageID) {
		fields = append(fields, chat.FieldLastMessageID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	switch name {
	case chat.FieldLastMessageID:
		m.ClearLastMessageID()
		return nil
	}
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	switch name {
	case chat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case chat.FieldType:
		m.ResetType()
		return nil
	case chat.FieldLastMessageID:
		m.ResetLastMessageID()
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.messages != nil {
		edges = append(edges, chat.EdgeMessages)
	}
	if m.last_message != nil {
		edges = append(edges, chat.EdgeLastMessage)
	}
	if m.private_chat != nil {
		edges = append(edges, chat.EdgePrivateChat)
	}
	if m.group_chat != nil {
		edges = append(edges, chat.EdgeGroupChat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case chat.EdgeLastMessage:
		if id := m.last_message; id != nil {
			return []ent.Value{*id}
		}
	case chat.EdgePrivateChat:
		if id := m.private_chat; id != nil {
			return []ent.Value{*id}
		}
	case chat.EdgeGroupChat:
		if id := m.group_chat; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmessages != nil {
		edges = append(edges, chat.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmessages {
		edges = append(edges, chat.EdgeMessages)
	}
	if m.clearedlast_message {
		edges = append(edges, chat.EdgeLastMessage)
	}
	if m.clearedprivate_chat {
		edges = append(edges, chat.EdgePrivateChat)
	}
	if m.clearedgroup_chat {
		edges = append(edges, chat.EdgeGroupChat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	switch name {
	case chat.EdgeMessages:
		return m.clearedmessages
	case chat.EdgeLastMessage:
		return m.clearedlast_message
	case chat.EdgePrivateChat:
		return m.clearedprivate_chat
	case chat.EdgeGroupChat:
		return m.clearedgroup_chat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	switch name {
	case chat.EdgeLastMessage:
		m.ClearLastMessage()
		return nil
	case chat.EdgePrivateChat:
		m.ClearPrivateChat()
		return nil
	case chat.EdgeGroupChat:
		m.ClearGroupChat()
		return nil
	}
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	switch name {
	case chat.EdgeMessages:
		m.ResetMessages()
		return nil
	case chat.EdgeLastMessage:
		m.ResetLastMessage()
		return nil
	case chat.EdgePrivateChat:
		m.ResetPrivateChat()
		return nil
	case chat.EdgeGroupChat:
		m.ResetGroupChat()
		return nil
	}
	return fmt.Errorf("unknown Chat edge %s", name)
}

// GroupChatMutation represents an operation that mutates the GroupChat nodes in the graph.
type GroupChatMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	description      *string
	avatar_file_name *string
	clearedFields    map[string]struct{}
	chat             *int
	clearedchat      bool
	creator          *int
	clearedcreator   bool
	members          map[int]struct{}
	removedmembers   map[int]struct{}
	clearedmembers   bool
	done             bool
	oldValue         func(context.Context) (*GroupChat, error)
	predicates       []predicate.GroupChat
}

var _ ent.Mutation = (*GroupChatMutation)(nil)

// groupchatOption allows management of the mutation configuration using functional options.
type groupchatOption func(*GroupChatMutation)

// newGroupChatMutation creates new mutation for the GroupChat entity.
func newGroupChatMutation(c config, op Op, opts ...groupchatOption) *GroupChatMutation {
	m := &GroupChatMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupChatID sets the ID field of the mutation.
func withGroupChatID(id int) groupchatOption {
	return func(m *GroupChatMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupChat
		)
		m.oldValue = func(ctx context.Context) (*GroupChat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupChat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupChat sets the old GroupChat of the mutation.
func withGroupChat(node *GroupChat) groupchatOption {
	return func(m *GroupChatMutation) {
		m.oldValue = func(context.Context) (*GroupChat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupChat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChatID sets the "chat_id" field.
func (m *GroupChatMutation) SetChatID(i int) {
	m.chat = &i
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *GroupChatMutation) ChatID() (r int, exists bool) {
	v := m.chat
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the GroupChat entity.
// If the GroupChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupChatMutation) OldChatID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *GroupChatMutation) ResetChatID() {
	m.chat = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *GroupChatMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *GroupChatMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the GroupChat entity.
// If the GroupChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupChatMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *GroupChatMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetName sets the "name" field.
func (m *GroupChatMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupChatMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GroupChat entity.
// If the GroupChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupChatMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupChatMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupChatMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupChatMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the GroupChat entity.
// If the GroupChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupChatMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupChatMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[groupchat.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupChatMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[groupchat.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupChatMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, groupchat.FieldDescription)
}

// SetAvatarFileName sets the "avatar_file_name" field.
func (m *GroupChatMutation) SetAvatarFileName(s string) {
	m.avatar_file_name = &s
}

// AvatarFileName returns the value of the "avatar_file_name" field in the mutation.
func (m *GroupChatMutation) AvatarFileName() (r string, exists bool) {
	v := m.avatar_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarFileName returns the old "avatar_file_name" field's value of the GroupChat entity.
// If the GroupChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupChatMutation) OldAvatarFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarFileName: %w", err)
	}
	return oldValue.AvatarFileName, nil
}

// ClearAvatarFileName clears the value of the "avatar_file_name" field.
func (m *GroupChatMutation) ClearAvatarFileName() {
	m.avatar_file_name = nil
	m.clearedFields[groupchat.FieldAvatarFileName] = struct{}{}
}

// AvatarFileNameCleared returns if the "avatar_file_name" field was cleared in this mutation.
func (m *GroupChatMutation) AvatarFileNameCleared() bool {
	_, ok := m.clearedFields[groupchat.FieldAvatarFileName]
	return ok
}

// ResetAvatarFileName resets all changes to the "avatar_file_name" field.
func (m *GroupChatMutation) ResetAvatarFileName() {
	m.avatar_file_name = nil
	delete(m.clearedFields, groupchat.FieldAvatarFileName)
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *GroupChatMutation) ClearChat() {
	m.clearedchat = true
	m.clearedFields[groupchat.FieldChatID] = struct{}{}
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *GroupChatMutation) ChatCleared() bool {
	return m.clearedchat
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *GroupChatMutation) ChatIDs() (ids []int) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *GroupChatMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *GroupChatMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *GroupChatMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[groupchat.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *GroupChatMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *GroupChatMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *GroupChatMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *GroupChatMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddMemberIDs adds the "members" edge to the GroupMember entity by ids.
func (m *GroupChatMutation) AddMemberIDs(ids ...int) {
	if m.members == nil {
		m.members = make(map[int]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the GroupMember entity.
func (m *GroupChatMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the GroupMember entity was cleared.
func (m *GroupChatMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the GroupMember entity by IDs.
func (m *GroupChatMutation) RemoveMemberIDs(ids ...int) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the GroupMember entity.
func (m *GroupChatMutation) RemovedMembersIDs() (ids []int) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *GroupChatMutation) MembersIDs() (ids []int) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *GroupChatMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the GroupChatMutation builder.
func (m *GroupChatMutation) Where(ps ...predicate.GroupChat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupChat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupChat).
func (m *GroupChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupChatMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.chat != nil {
		fields = append(fields, groupchat.FieldChatID)
	}
	if m.creator != nil {
		fields = append(fields, groupchat.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, groupchat.FieldName)
	}
	if m.description != nil {
		fields = append(fields, groupchat.FieldDescription)
	}
	if m.avatar_file_name != nil {
		fields = append(fields, groupchat.FieldAvatarFileName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupchat.FieldChatID:
		return m.ChatID()
	case groupchat.FieldCreatedBy:
		return m.CreatedBy()
	case groupchat.FieldName:
		return m.Name()
	case groupchat.FieldDescription:
		return m.Description()
	case groupchat.FieldAvatarFileName:
		return m.AvatarFileName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupchat.FieldChatID:
		return m.OldChatID(ctx)
	case groupchat.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case groupchat.FieldName:
		return m.OldName(ctx)
	case groupchat.FieldDescription:
		return m.OldDescription(ctx)
	case groupchat.FieldAvatarFileName:
		return m.OldAvatarFileName(ctx)
	}
	return nil, fmt.Errorf("unknown GroupChat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupchat.FieldChatID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case groupchat.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case groupchat.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case groupchat.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case groupchat.FieldAvatarFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarFileName(v)
		return nil
	}
	return fmt.Errorf("unknown GroupChat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupChatMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupChatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupChat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupchat.FieldDescription) {
		fields = append(fields, groupchat.FieldDescription)
	}
	if m.FieldCleared(groupchat.FieldAvatarFileName) {
		fields = append(fields, groupchat.FieldAvatarFileName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupChatMutation) ClearField(name string) error {
	switch name {
	case groupchat.FieldDescription:
		m.ClearDescription()
		return nil
	case groupchat.FieldAvatarFileName:
		m.ClearAvatarFileName()
		return nil
	}
	return fmt.Errorf("unknown GroupChat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupChatMutation) ResetField(name string) error {
	switch name {
	case groupchat.FieldChatID:
		m.ResetChatID()
		return nil
	case groupchat.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case groupchat.FieldName:
		m.ResetName()
		return nil
	case groupchat.FieldDescription:
		m.ResetDescription()
		return nil
	case groupchat.FieldAvatarFileName:
		m.ResetAvatarFileName()
		return nil
	}
	return fmt.Errorf("unknown GroupChat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.chat != nil {
		edges = append(edges, groupchat.EdgeChat)
	}
	if m.creator != nil {
		edges = append(edges, groupchat.EdgeCreator)
	}
	if m.members != nil {
		edges = append(edges, groupchat.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupchat.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	case groupchat.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case groupchat.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, groupchat.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupChatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case groupchat.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchat {
		edges = append(edges, groupchat.EdgeChat)
	}
	if m.clearedcreator {
		edges = append(edges, groupchat.EdgeCreator)
	}
	if m.clearedmembers {
		edges = append(edges, groupchat.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupChatMutation) EdgeCleared(name string) bool {
	switch name {
	case groupchat.EdgeChat:
		return m.clearedchat
	case groupchat.EdgeCreator:
		return m.clearedcreator
	case groupchat.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupChatMutation) ClearEdge(name string) error {
	switch name {
	case groupchat.EdgeChat:
		m.ClearChat()
		return nil
	case groupchat.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown GroupChat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupChatMutation) ResetEdge(name string) error {
	switch name {
	case groupchat.EdgeChat:
		m.ResetChat()
		return nil
	case groupchat.EdgeCreator:
		m.ResetCreator()
		return nil
	case groupchat.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown GroupChat edge %s", name)
}

// GroupMemberMutation represents an operation that mutates the GroupMember nodes in the graph.
type GroupMemberMutation struct {
	config
	op                Op
	typ               string
	id                *int
	role              *groupmember.Role
	last_read_at      *time.Time
	joined_at         *time.Time
	clearedFields     map[string]struct{}
	group_chat        *int
	clearedgroup_chat bool
	user              *int
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*GroupMember, error)
	predicates        []predicate.GroupMember
}

var _ ent.Mutation = (*GroupMemberMutation)(nil)

// groupmemberOption allows management of the mutation configuration using functional options.
type groupmemberOption func(*GroupMemberMutation)

// newGroupMemberMutation creates new mutation for the GroupMember entity.
func newGroupMemberMutation(c config, op Op, opts ...groupmemberOption) *GroupMemberMutation {
	m := &GroupMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupMemberID sets the ID field of the mutation.
func withGroupMemberID(id int) groupmemberOption {
	return func(m *GroupMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupMember
		)
		m.oldValue = func(ctx context.Context) (*GroupMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupMember sets the old GroupMember of the mutation.
func withGroupMember(node *GroupMember) groupmemberOption {
	return func(m *GroupMemberMutation) {
		m.oldValue = func(context.Context) (*GroupMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GroupMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupChatID sets the "group_chat_id" field.
func (m *GroupMemberMutation) SetGroupChatID(i int) {
	m.group_chat = &i
}

// GroupChatID returns the value of the "group_chat_id" field in the mutation.
func (m *GroupMemberMutation) GroupChatID() (r int, exists bool) {
	v := m.group_chat
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupChatID returns the old "group_chat_id" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldGroupChatID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupChatID: %w", err)
	}
	return oldValue.GroupChatID, nil
}

// ResetGroupChatID resets all changes to the "group_chat_id" field.
func (m *GroupMemberMutation) ResetGroupChatID() {
	m.group_chat = nil
}

// SetUserID sets the "user_id" field.
func (m *GroupMemberMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *GroupMemberMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *GroupMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *GroupMemberMutation) SetRole(gr groupmember.Role) {
	m.role = &gr
}

// Role returns the value of the "role" field in the mutation.
func (m *GroupMemberMutation) Role() (r groupmember.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldRole(ctx context.Context) (v groupmember.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *GroupMemberMutation) ResetRole() {
	m.role = nil
}

// SetLastReadAt sets the "last_read_at" field.
func (m *GroupMemberMutation) SetLastReadAt(t time.Time) {
	m.last_read_at = &t
}

// LastReadAt returns the value of the "last_read_at" field in the mutation.
func (m *GroupMemberMutation) LastReadAt() (r time.Time, exists bool) {
	v := m.last_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastReadAt returns the old "last_read_at" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldLastReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastReadAt: %w", err)
	}
	return oldValue.LastReadAt, nil
}

// ClearLastReadAt clears the value of the "last_read_at" field.
func (m *GroupMemberMutation) ClearLastReadAt() {
	m.last_read_at = nil
	m.clearedFields[groupmember.FieldLastReadAt] = struct{}{}
}

// LastReadAtCleared returns if the "last_read_at" field was cleared in this mutation.
func (m *GroupMemberMutation) LastReadAtCleared() bool {
	_, ok := m.clearedFields[groupmember.FieldLastReadAt]
	return ok
}

// ResetLastReadAt resets all changes to the "last_read_at" field.
func (m *GroupMemberMutation) ResetLastReadAt() {
	m.last_read_at = nil
	delete(m.clearedFields, groupmember.FieldLastReadAt)
}

// SetJoinedAt sets the "joined_at" field.
func (m *GroupMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *GroupMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the GroupMember entity.
// If the GroupMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *GroupMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// ClearGroupChat clears the "group_chat" edge to the GroupChat entity.
func (m *GroupMemberMutation) ClearGroupChat() {
	m.clearedgroup_chat = true
	m.clearedFields[groupmember.FieldGroupChatID] = struct{}{}
}

// GroupChatCleared reports if the "group_chat" edge to the GroupChat entity was cleared.
func (m *GroupMemberMutation) GroupChatCleared() bool {
	return m.clearedgroup_chat
}

// GroupChatIDs returns the "group_chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupChatID instead. It exists only for internal usage by the builders.
func (m *GroupMemberMutation) GroupChatIDs() (ids []int) {
	if id := m.group_chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroupChat resets all changes to the "group_chat" edge.
func (m *GroupMemberMutation) ResetGroupChat() {
	m.group_chat = nil
	m.clearedgroup_chat = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *GroupMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[groupmember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *GroupMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *GroupMemberMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *GroupMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the GroupMemberMutation builder.
func (m *GroupMemberMutation) Where(ps ...predicate.GroupMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GroupMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GroupMember).
func (m *GroupMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMemberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.group_chat != nil {
		fields = append(fields, groupmember.FieldGroupChatID)
	}
	if m.user != nil {
		fields = append(fields, groupmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, groupmember.FieldRole)
	}
	if m.last_read_at != nil {
		fields = append(fields, groupmember.FieldLastReadAt)
	}
	if m.joined_at != nil {
		fields = append(fields, groupmember.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupmember.FieldGroupChatID:
		return m.GroupChatID()
	case groupmember.FieldUserID:
		return m.UserID()
	case groupmember.FieldRole:
		return m.Role()
	case groupmember.FieldLastReadAt:
		return m.LastReadAt()
	case groupmember.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupmember.FieldGroupChatID:
		return m.OldGroupChatID(ctx)
	case groupmember.FieldUserID:
		return m.OldUserID(ctx)
	case groupmember.FieldRole:
		return m.OldRole(ctx)
	case groupmember.FieldLastReadAt:
		return m.OldLastReadAt(ctx)
	case groupmember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GroupMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupmember.FieldGroupChatID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupChatID(v)
		return nil
	case groupmember.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case groupmember.FieldRole:
		v, ok := value.(groupmember.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case groupmember.FieldLastReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastReadAt(v)
		return nil
	case groupmember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GroupMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(groupmember.FieldLastReadAt) {
		fields = append(fields, groupmember.FieldLastReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMemberMutation) ClearField(name string) error {
	switch name {
	case groupmember.FieldLastReadAt:
		m.ClearLastReadAt()
		return nil
	}
	return fmt.Errorf("unknown GroupMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMemberMutation) ResetField(name string) error {
	switch name {
	case groupmember.FieldGroupChatID:
		m.ResetGroupChatID()
		return nil
	case groupmember.FieldUserID:
		m.ResetUserID()
		return nil
	case groupmember.FieldRole:
		m.ResetRole()
		return nil
	case groupmember.FieldLastReadAt:
		m.ResetLastReadAt()
		return nil
	case groupmember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown GroupMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group_chat != nil {
		edges = append(edges, groupmember.EdgeGroupChat)
	}
	if m.user != nil {
		edges = append(edges, groupmember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case groupmember.EdgeGroupChat:
		if id := m.group_chat; id != nil {
			return []ent.Value{*id}
		}
	case groupmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup_chat {
		edges = append(edges, groupmember.EdgeGroupChat)
	}
	if m.cleareduser {
		edges = append(edges, groupmember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case groupmember.EdgeGroupChat:
		return m.clearedgroup_chat
	case groupmember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMemberMutation) ClearEdge(name string) error {
	switch name {
	case groupmember.EdgeGroupChat:
		m.ClearGroupChat()
		return nil
	case groupmember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown GroupMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMemberMutation) ResetEdge(name string) error {
	switch name {
	case groupmember.EdgeGroupChat:
		m.ResetGroupChat()
		return nil
	case groupmember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown GroupMember edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	created_at                     *time.Time
	updated_at                     *time.Time
	content                        *string
	deleted_at                     *time.Time
	is_edited                      *bool
	clearedFields                  map[string]struct{}
	chat                           *int
	clearedchat                    bool
	sender                         *int
	clearedsender                  bool
	replies                        map[int]struct{}
	removedreplies                 map[int]struct{}
	clearedreplies                 bool
	reply_to                       *int
	clearedreply_to                bool
	attachments                    map[int]struct{}
	removedattachments             map[int]struct{}
	clearedattachments             bool
	chats_with_last_message        map[int]struct{}
	removedchats_with_last_message map[int]struct{}
	clearedchats_with_last_message bool
	done                           bool
	oldValue                       func(context.Context) (*Message, error)
	predicates                     []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetChatID sets the "chat_id" field.
func (m *MessageMutation) SetChatID(i int) {
	m.chat = &i
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *MessageMutation) ChatID() (r int, exists bool) {
	v := m.chat
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldChatID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *MessageMutation) ResetChatID() {
	m.chat = nil
}

// SetSenderID sets the "sender_id" field.
func (m *MessageMutation) SetSenderID(i int) {
	m.sender = &i
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *MessageMutation) SenderID() (r int, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSenderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *MessageMutation) ResetSenderID() {
	m.sender = nil
}

// SetReplyToID sets the "reply_to_id" field.
func (m *MessageMutation) SetReplyToID(i int) {
	m.reply_to = &i
}

// ReplyToID returns the value of the "reply_to_id" field in the mutation.
func (m *MessageMutation) ReplyToID() (r int, exists bool) {
	v := m.reply_to
	if v == nil {
		return
	}
	return *v, true
}

// OldReplyToID returns the old "reply_to_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldReplyToID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReplyToID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReplyToID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplyToID: %w", err)
	}
	return oldValue.ReplyToID, nil
}

// ClearReplyToID clears the value of the "reply_to_id" field.
func (m *MessageMutation) ClearReplyToID() {
	m.reply_to = nil
	m.clearedFields[message.FieldReplyToID] = struct{}{}
}

// ReplyToIDCleared returns if the "reply_to_id" field was cleared in this mutation.
func (m *MessageMutation) ReplyToIDCleared() bool {
	_, ok := m.clearedFields[message.FieldReplyToID]
	return ok
}

// ResetReplyToID resets all changes to the "reply_to_id" field.
func (m *MessageMutation) ResetReplyToID() {
	m.reply_to = nil
	delete(m.clearedFields, message.FieldReplyToID)
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[message.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[message.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, message.FieldContent)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetIsEdited sets the "is_edited" field.
func (m *MessageMutation) SetIsEdited(b bool) {
	m.is_edited = &b
}

// IsEdited returns the value of the "is_edited" field in the mutation.
func (m *MessageMutation) IsEdited() (r bool, exists bool) {
	v := m.is_edited
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEdited returns the old "is_edited" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldIsEdited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEdited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEdited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEdited: %w", err)
	}
	return oldValue.IsEdited, nil
}

// ResetIsEdited resets all changes to the "is_edited" field.
func (m *MessageMutation) ResetIsEdited() {
	m.is_edited = nil
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *MessageMutation) ClearChat() {
	m.clearedchat = true
	m.clearedFields[message.FieldChatID] = struct{}{}
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *MessageMutation) ChatCleared() bool {
	return m.clearedchat
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ChatIDs() (ids []int) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *MessageMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// ClearSender clears the "sender" edge to the User entity.
func (m *MessageMutation) ClearSender() {
	m.clearedsender = true
	m.clearedFields[message.FieldSenderID] = struct{}{}
}

// SenderCleared reports if the "sender" edge to the User entity was cleared.
func (m *MessageMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) SenderIDs() (ids []int) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *MessageMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// AddReplyIDs adds the "replies" edge to the Message entity by ids.
func (m *MessageMutation) AddReplyIDs(ids ...int) {
	if m.replies == nil {
		m.replies = make(map[int]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Message entity.
func (m *MessageMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Message entity was cleared.
func (m *MessageMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Message entity by IDs.
func (m *MessageMutation) RemoveReplyIDs(ids ...int) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Message entity.
func (m *MessageMutation) RemovedRepliesIDs() (ids []int) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *MessageMutation) RepliesIDs() (ids []int) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *MessageMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// ClearReplyTo clears the "reply_to" edge to the Message entity.
func (m *MessageMutation) ClearReplyTo() {
	m.clearedreply_to = true
	m.clearedFields[message.FieldReplyToID] = struct{}{}
}

// ReplyToCleared reports if the "reply_to" edge to the Message entity was cleared.
func (m *MessageMutation) ReplyToCleared() bool {
	return m.ReplyToIDCleared() || m.clearedreply_to
}

// ReplyToIDs returns the "reply_to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReplyToID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ReplyToIDs() (ids []int) {
	if id := m.reply_to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReplyTo resets all changes to the "reply_to" edge.
func (m *MessageMutation) ResetReplyTo() {
	m.reply_to = nil
	m.clearedreply_to = false
}

// AddAttachmentIDs adds the "attachments" edge to the Attachment entity by ids.
func (m *MessageMutation) AddAttachmentIDs(ids ...int) {
	if m.attachments == nil {
		m.attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the Attachment entity.
func (m *MessageMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the Attachment entity was cleared.
func (m *MessageMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the Attachment entity by IDs.
func (m *MessageMutation) RemoveAttachmentIDs(ids ...int) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the Attachment entity.
func (m *MessageMutation) RemovedAttachmentsIDs() (ids []int) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *MessageMutation) AttachmentsIDs() (ids []int) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *MessageMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddChatsWithLastMessageIDs adds the "chats_with_last_message" edge to the Chat entity by ids.
func (m *MessageMutation) AddChatsWithLastMessageIDs(ids ...int) {
	if m.chats_with_last_message == nil {
		m.chats_with_last_message = make(map[int]struct{})
	}
	for i := range ids {
		m.chats_with_last_message[ids[i]] = struct{}{}
	}
}

// ClearChatsWithLastMessage clears the "chats_with_last_message" edge to the Chat entity.
func (m *MessageMutation) ClearChatsWithLastMessage() {
	m.clearedchats_with_last_message = true
}

// ChatsWithLastMessageCleared reports if the "chats_with_last_message" edge to the Chat entity was cleared.
func (m *MessageMutation) ChatsWithLastMessageCleared() bool {
	return m.clearedchats_with_last_message
}

// RemoveChatsWithLastMessageIDs removes the "chats_with_last_message" edge to the Chat entity by IDs.
func (m *MessageMutation) RemoveChatsWithLastMessageIDs(ids ...int) {
	if m.removedchats_with_last_message == nil {
		m.removedchats_with_last_message = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chats_with_last_message, ids[i])
		m.removedchats_with_last_message[ids[i]] = struct{}{}
	}
}

// RemovedChatsWithLastMessage returns the removed IDs of the "chats_with_last_message" edge to the Chat entity.
func (m *MessageMutation) RemovedChatsWithLastMessageIDs() (ids []int) {
	for id := range m.removedchats_with_last_message {
		ids = append(ids, id)
	}
	return
}

// ChatsWithLastMessageIDs returns the "chats_with_last_message" edge IDs in the mutation.
func (m *MessageMutation) ChatsWithLastMessageIDs() (ids []int) {
	for id := range m.chats_with_last_message {
		ids = append(ids, id)
	}
	return
}

// ResetChatsWithLastMessage resets all changes to the "chats_with_last_message" edge.
func (m *MessageMutation) ResetChatsWithLastMessage() {
	m.chats_with_last_message = nil
	m.clearedchats_with_last_message = false
	m.removedchats_with_last_message = nil
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.chat != nil {
		fields = append(fields, message.FieldChatID)
	}
	if m.sender != nil {
		fields = append(fields, message.FieldSenderID)
	}
	if m.reply_to != nil {
		fields = append(fields, message.FieldReplyToID)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	if m.is_edited != nil {
		fields = append(fields, message.FieldIsEdited)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	case message.FieldChatID:
		return m.ChatID()
	case message.FieldSenderID:
		return m.SenderID()
	case message.FieldReplyToID:
		return m.ReplyToID()
	case message.FieldContent:
		return m.Content()
	case message.FieldDeletedAt:
		return m.DeletedAt()
	case message.FieldIsEdited:
		return m.IsEdited()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case message.FieldChatID:
		return m.OldChatID(ctx)
	case message.FieldSenderID:
		return m.OldSenderID(ctx)
	case message.FieldReplyToID:
		return m.OldReplyToID(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case message.FieldIsEdited:
		return m.OldIsEdited(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case message.FieldChatID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case message.FieldSenderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case message.FieldReplyToID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplyToID(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case message.FieldIsEdited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEdited(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldReplyToID) {
		fields = append(fields, message.FieldReplyToID)
	}
	if m.FieldCleared(message.FieldContent) {
		fields = append(fields, message.FieldContent)
	}
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldReplyToID:
		m.ClearReplyToID()
		return nil
	case message.FieldContent:
		m.ClearContent()
		return nil
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case message.FieldChatID:
		m.ResetChatID()
		return nil
	case message.FieldSenderID:
		m.ResetSenderID()
		return nil
	case message.FieldReplyToID:
		m.ResetReplyToID()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case message.FieldIsEdited:
		m.ResetIsEdited()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.chat != nil {
		edges = append(edges, message.EdgeChat)
	}
	if m.sender != nil {
		edges = append(edges, message.EdgeSender)
	}
	if m.replies != nil {
		edges = append(edges, message.EdgeReplies)
	}
	if m.reply_to != nil {
		edges = append(edges, message.EdgeReplyTo)
	}
	if m.attachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	if m.chats_with_last_message != nil {
		edges = append(edges, message.EdgeChatsWithLastMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeReplyTo:
		if id := m.reply_to; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeChatsWithLastMessage:
		ids := make([]ent.Value, 0, len(m.chats_with_last_message))
		for id := range m.chats_with_last_message {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedreplies != nil {
		edges = append(edges, message.EdgeReplies)
	}
	if m.removedattachments != nil {
		edges = append(edges, message.EdgeAttachments)
	}
	if m.removedchats_with_last_message != nil {
		edges = append(edges, message.EdgeChatsWithLastMessage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case message.EdgeChatsWithLastMessage:
		ids := make([]ent.Value, 0, len(m.removedchats_with_last_message))
		for id := range m.removedchats_with_last_message {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedchat {
		edges = append(edges, message.EdgeChat)
	}
	if m.clearedsender {
		edges = append(edges, message.EdgeSender)
	}
	if m.clearedreplies {
		edges = append(edges, message.EdgeReplies)
	}
	if m.clearedreply_to {
		edges = append(edges, message.EdgeReplyTo)
	}
	if m.clearedattachments {
		edges = append(edges, message.EdgeAttachments)
	}
	if m.clearedchats_with_last_message {
		edges = append(edges, message.EdgeChatsWithLastMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeChat:
		return m.clearedchat
	case message.EdgeSender:
		return m.clearedsender
	case message.EdgeReplies:
		return m.clearedreplies
	case message.EdgeReplyTo:
		return m.clearedreply_to
	case message.EdgeAttachments:
		return m.clearedattachments
	case message.EdgeChatsWithLastMessage:
		return m.clearedchats_with_last_message
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeChat:
		m.ClearChat()
		return nil
	case message.EdgeSender:
		m.ClearSender()
		return nil
	case message.EdgeReplyTo:
		m.ClearReplyTo()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeChat:
		m.ResetChat()
		return nil
	case message.EdgeSender:
		m.ResetSender()
		return nil
	case message.EdgeReplies:
		m.ResetReplies()
		return nil
	case message.EdgeReplyTo:
		m.ResetReplyTo()
		return nil
	case message.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case message.EdgeChatsWithLastMessage:
		m.ResetChatsWithLastMessage()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// OTPMutation represents an operation that mutates the OTP nodes in the graph.
type OTPMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	email         *string
	code          *string
	mode          *otp.Mode
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OTP, error)
	predicates    []predicate.OTP
}

var _ ent.Mutation = (*OTPMutation)(nil)

// otpOption allows management of the mutation configuration using functional options.
type otpOption func(*OTPMutation)

// newOTPMutation creates new mutation for the OTP entity.
func newOTPMutation(c config, op Op, opts ...otpOption) *OTPMutation {
	m := &OTPMutation{
		config:        c,
		op:            op,
		typ:           TypeOTP,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOTPID sets the ID field of the mutation.
func withOTPID(id int) otpOption {
	return func(m *OTPMutation) {
		var (
			err   error
			once  sync.Once
			value *OTP
		)
		m.oldValue = func(ctx context.Context) (*OTP, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OTP.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOTP sets the old OTP of the mutation.
func withOTP(node *OTP) otpOption {
	return func(m *OTPMutation) {
		m.oldValue = func(context.Context) (*OTP, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OTPMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OTPMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OTPMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OTPMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OTP.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OTPMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OTPMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OTPMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OTPMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OTPMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OTPMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *OTPMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *OTPMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *OTPMutation) ResetEmail() {
	m.email = nil
}

// SetCode sets the "code" field.
func (m *OTPMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OTPMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OTPMutation) ResetCode() {
	m.code = nil
}

// SetMode sets the "mode" field.
func (m *OTPMutation) SetMode(o otp.Mode) {
	m.mode = &o
}

// Mode returns the value of the "mode" field in the mutation.
func (m *OTPMutation) Mode() (r otp.Mode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldMode(ctx context.Context) (v otp.Mode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *OTPMutation) ResetMode() {
	m.mode = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *OTPMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *OTPMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the OTP entity.
// If the OTP object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTPMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *OTPMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// Where appends a list predicates to the OTPMutation builder.
func (m *OTPMutation) Where(ps ...predicate.OTP) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OTPMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OTPMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OTP, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OTPMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OTPMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OTP).
func (m *OTPMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OTPMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, otp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, otp.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, otp.FieldEmail)
	}
	if m.code != nil {
		fields = append(fields, otp.FieldCode)
	}
	if m.mode != nil {
		fields = append(fields, otp.FieldMode)
	}
	if m.expires_at != nil {
		fields = append(fields, otp.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OTPMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otp.FieldCreatedAt:
		return m.CreatedAt()
	case otp.FieldUpdatedAt:
		return m.UpdatedAt()
	case otp.FieldEmail:
		return m.Email()
	case otp.FieldCode:
		return m.Code()
	case otp.FieldMode:
		return m.Mode()
	case otp.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OTPMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case otp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case otp.FieldEmail:
		return m.OldEmail(ctx)
	case otp.FieldCode:
		return m.OldCode(ctx)
	case otp.FieldMode:
		return m.OldMode(ctx)
	case otp.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown OTP field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OTPMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case otp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case otp.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case otp.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case otp.FieldMode:
		v, ok := value.(otp.Mode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case otp.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown OTP field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OTPMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OTPMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OTPMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OTP numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OTPMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OTPMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OTPMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OTP nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OTPMutation) ResetField(name string) error {
	switch name {
	case otp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case otp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case otp.FieldEmail:
		m.ResetEmail()
		return nil
	case otp.FieldCode:
		m.ResetCode()
		return nil
	case otp.FieldMode:
		m.ResetMode()
		return nil
	case otp.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown OTP field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OTPMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OTPMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OTPMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OTPMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OTPMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OTPMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OTPMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OTP unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OTPMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OTP edge %s", name)
}

// PrivateChatMutation represents an operation that mutates the PrivateChat nodes in the graph.
type PrivateChatMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	user1_last_read_at *time.Time
	user2_last_read_at *time.Time
	clearedFields      map[string]struct{}
	chat               *int
	clearedchat        bool
	user1              *int
	cleareduser1       bool
	user2              *int
	cleareduser2       bool
	done               bool
	oldValue           func(context.Context) (*PrivateChat, error)
	predicates         []predicate.PrivateChat
}

var _ ent.Mutation = (*PrivateChatMutation)(nil)

// privatechatOption allows management of the mutation configuration using functional options.
type privatechatOption func(*PrivateChatMutation)

// newPrivateChatMutation creates new mutation for the PrivateChat entity.
func newPrivateChatMutation(c config, op Op, opts ...privatechatOption) *PrivateChatMutation {
	m := &PrivateChatMutation{
		config:        c,
		op:            op,
		typ:           TypePrivateChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrivateChatID sets the ID field of the mutation.
func withPrivateChatID(id int) privatechatOption {
	return func(m *PrivateChatMutation) {
		var (
			err   error
			once  sync.Once
			value *PrivateChat
		)
		m.oldValue = func(ctx context.Context) (*PrivateChat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrivateChat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrivateChat sets the old PrivateChat of the mutation.
func withPrivateChat(node *PrivateChat) privatechatOption {
	return func(m *PrivateChatMutation) {
		m.oldValue = func(context.Context) (*PrivateChat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrivateChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrivateChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrivateChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrivateChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrivateChat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChatID sets the "chat_id" field.
func (m *PrivateChatMutation) SetChatID(i int) {
	m.chat = &i
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *PrivateChatMutation) ChatID() (r int, exists bool) {
	v := m.chat
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the PrivateChat entity.
// If the PrivateChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivateChatMutation) OldChatID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *PrivateChatMutation) ResetChatID() {
	m.chat = nil
}

// SetUser1ID sets the "user1_id" field.
func (m *PrivateChatMutation) SetUser1ID(i int) {
	m.user1 = &i
}

// User1ID returns the value of the "user1_id" field in the mutation.
func (m *PrivateChatMutation) User1ID() (r int, exists bool) {
	v := m.user1
	if v == nil {
		return
	}
	return *v, true
}

// OldUser1ID returns the old "user1_id" field's value of the PrivateChat entity.
// If the PrivateChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivateChatMutation) OldUser1ID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser1ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser1ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser1ID: %w", err)
	}
	return oldValue.User1ID, nil
}

// ResetUser1ID resets all changes to the "user1_id" field.
func (m *PrivateChatMutation) ResetUser1ID() {
	m.user1 = nil
}

// SetUser2ID sets the "user2_id" field.
func (m *PrivateChatMutation) SetUser2ID(i int) {
	m.user2 = &i
}

// User2ID returns the value of the "user2_id" field in the mutation.
func (m *PrivateChatMutation) User2ID() (r int, exists bool) {
	v := m.user2
	if v == nil {
		return
	}
	return *v, true
}

// OldUser2ID returns the old "user2_id" field's value of the PrivateChat entity.
// If the PrivateChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivateChatMutation) OldUser2ID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser2ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser2ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser2ID: %w", err)
	}
	return oldValue.User2ID, nil
}

// ResetUser2ID resets all changes to the "user2_id" field.
func (m *PrivateChatMutation) ResetUser2ID() {
	m.user2 = nil
}

// SetUser1LastReadAt sets the "user1_last_read_at" field.
func (m *PrivateChatMutation) SetUser1LastReadAt(t time.Time) {
	m.user1_last_read_at = &t
}

// User1LastReadAt returns the value of the "user1_last_read_at" field in the mutation.
func (m *PrivateChatMutation) User1LastReadAt() (r time.Time, exists bool) {
	v := m.user1_last_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUser1LastReadAt returns the old "user1_last_read_at" field's value of the PrivateChat entity.
// If the PrivateChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivateChatMutation) OldUser1LastReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser1LastReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser1LastReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser1LastReadAt: %w", err)
	}
	return oldValue.User1LastReadAt, nil
}

// ClearUser1LastReadAt clears the value of the "user1_last_read_at" field.
func (m *PrivateChatMutation) ClearUser1LastReadAt() {
	m.user1_last_read_at = nil
	m.clearedFields[privatechat.FieldUser1LastReadAt] = struct{}{}
}

// User1LastReadAtCleared returns if the "user1_last_read_at" field was cleared in this mutation.
func (m *PrivateChatMutation) User1LastReadAtCleared() bool {
	_, ok := m.clearedFields[privatechat.FieldUser1LastReadAt]
	return ok
}

// ResetUser1LastReadAt resets all changes to the "user1_last_read_at" field.
func (m *PrivateChatMutation) ResetUser1LastReadAt() {
	m.user1_last_read_at = nil
	delete(m.clearedFields, privatechat.FieldUser1LastReadAt)
}

// SetUser2LastReadAt sets the "user2_last_read_at" field.
func (m *PrivateChatMutation) SetUser2LastReadAt(t time.Time) {
	m.user2_last_read_at = &t
}

// User2LastReadAt returns the value of the "user2_last_read_at" field in the mutation.
func (m *PrivateChatMutation) User2LastReadAt() (r time.Time, exists bool) {
	v := m.user2_last_read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUser2LastReadAt returns the old "user2_last_read_at" field's value of the PrivateChat entity.
// If the PrivateChat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrivateChatMutation) OldUser2LastReadAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser2LastReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser2LastReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser2LastReadAt: %w", err)
	}
	return oldValue.User2LastReadAt, nil
}

// ClearUser2LastReadAt clears the value of the "user2_last_read_at" field.
func (m *PrivateChatMutation) ClearUser2LastReadAt() {
	m.user2_last_read_at = nil
	m.clearedFields[privatechat.FieldUser2LastReadAt] = struct{}{}
}

// User2LastReadAtCleared returns if the "user2_last_read_at" field was cleared in this mutation.
func (m *PrivateChatMutation) User2LastReadAtCleared() bool {
	_, ok := m.clearedFields[privatechat.FieldUser2LastReadAt]
	return ok
}

// ResetUser2LastReadAt resets all changes to the "user2_last_read_at" field.
func (m *PrivateChatMutation) ResetUser2LastReadAt() {
	m.user2_last_read_at = nil
	delete(m.clearedFields, privatechat.FieldUser2LastReadAt)
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *PrivateChatMutation) ClearChat() {
	m.clearedchat = true
	m.clearedFields[privatechat.FieldChatID] = struct{}{}
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *PrivateChatMutation) ChatCleared() bool {
	return m.clearedchat
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *PrivateChatMutation) ChatIDs() (ids []int) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *PrivateChatMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// ClearUser1 clears the "user1" edge to the User entity.
func (m *PrivateChatMutation) ClearUser1() {
	m.cleareduser1 = true
	m.clearedFields[privatechat.FieldUser1ID] = struct{}{}
}

// User1Cleared reports if the "user1" edge to the User entity was cleared.
func (m *PrivateChatMutation) User1Cleared() bool {
	return m.cleareduser1
}

// User1IDs returns the "user1" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// User1ID instead. It exists only for internal usage by the builders.
func (m *PrivateChatMutation) User1IDs() (ids []int) {
	if id := m.user1; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser1 resets all changes to the "user1" edge.
func (m *PrivateChatMutation) ResetUser1() {
	m.user1 = nil
	m.cleareduser1 = false
}

// ClearUser2 clears the "user2" edge to the User entity.
func (m *PrivateChatMutation) ClearUser2() {
	m.cleareduser2 = true
	m.clearedFields[privatechat.FieldUser2ID] = struct{}{}
}

// User2Cleared reports if the "user2" edge to the User entity was cleared.
func (m *PrivateChatMutation) User2Cleared() bool {
	return m.cleareduser2
}

// User2IDs returns the "user2" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// User2ID instead. It exists only for internal usage by the builders.
func (m *PrivateChatMutation) User2IDs() (ids []int) {
	if id := m.user2; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser2 resets all changes to the "user2" edge.
func (m *PrivateChatMutation) ResetUser2() {
	m.user2 = nil
	m.cleareduser2 = false
}

// Where appends a list predicates to the PrivateChatMutation builder.
func (m *PrivateChatMutation) Where(ps ...predicate.PrivateChat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrivateChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrivateChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrivateChat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrivateChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrivateChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrivateChat).
func (m *PrivateChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrivateChatMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.chat != nil {
		fields = append(fields, privatechat.FieldChatID)
	}
	if m.user1 != nil {
		fields = append(fields, privatechat.FieldUser1ID)
	}
	if m.user2 != nil {
		fields = append(fields, privatechat.FieldUser2ID)
	}
	if m.user1_last_read_at != nil {
		fields = append(fields, privatechat.FieldUser1LastReadAt)
	}
	if m.user2_last_read_at != nil {
		fields = append(fields, privatechat.FieldUser2LastReadAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrivateChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case privatechat.FieldChatID:
		return m.ChatID()
	case privatechat.FieldUser1ID:
		return m.User1ID()
	case privatechat.FieldUser2ID:
		return m.User2ID()
	case privatechat.FieldUser1LastReadAt:
		return m.User1LastReadAt()
	case privatechat.FieldUser2LastReadAt:
		return m.User2LastReadAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrivateChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case privatechat.FieldChatID:
		return m.OldChatID(ctx)
	case privatechat.FieldUser1ID:
		return m.OldUser1ID(ctx)
	case privatechat.FieldUser2ID:
		return m.OldUser2ID(ctx)
	case privatechat.FieldUser1LastReadAt:
		return m.OldUser1LastReadAt(ctx)
	case privatechat.FieldUser2LastReadAt:
		return m.OldUser2LastReadAt(ctx)
	}
	return nil, fmt.Errorf("unknown PrivateChat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrivateChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case privatechat.FieldChatID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case privatechat.FieldUser1ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser1ID(v)
		return nil
	case privatechat.FieldUser2ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser2ID(v)
		return nil
	case privatechat.FieldUser1LastReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser1LastReadAt(v)
		return nil
	case privatechat.FieldUser2LastReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser2LastReadAt(v)
		return nil
	}
	return fmt.Errorf("unknown PrivateChat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrivateChatMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrivateChatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrivateChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrivateChat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrivateChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(privatechat.FieldUser1LastReadAt) {
		fields = append(fields, privatechat.FieldUser1LastReadAt)
	}
	if m.FieldCleared(privatechat.FieldUser2LastReadAt) {
		fields = append(fields, privatechat.FieldUser2LastReadAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrivateChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrivateChatMutation) ClearField(name string) error {
	switch name {
	case privatechat.FieldUser1LastReadAt:
		m.ClearUser1LastReadAt()
		return nil
	case privatechat.FieldUser2LastReadAt:
		m.ClearUser2LastReadAt()
		return nil
	}
	return fmt.Errorf("unknown PrivateChat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrivateChatMutation) ResetField(name string) error {
	switch name {
	case privatechat.FieldChatID:
		m.ResetChatID()
		return nil
	case privatechat.FieldUser1ID:
		m.ResetUser1ID()
		return nil
	case privatechat.FieldUser2ID:
		m.ResetUser2ID()
		return nil
	case privatechat.FieldUser1LastReadAt:
		m.ResetUser1LastReadAt()
		return nil
	case privatechat.FieldUser2LastReadAt:
		m.ResetUser2LastReadAt()
		return nil
	}
	return fmt.Errorf("unknown PrivateChat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrivateChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.chat != nil {
		edges = append(edges, privatechat.EdgeChat)
	}
	if m.user1 != nil {
		edges = append(edges, privatechat.EdgeUser1)
	}
	if m.user2 != nil {
		edges = append(edges, privatechat.EdgeUser2)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrivateChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case privatechat.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	case privatechat.EdgeUser1:
		if id := m.user1; id != nil {
			return []ent.Value{*id}
		}
	case privatechat.EdgeUser2:
		if id := m.user2; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrivateChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrivateChatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrivateChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchat {
		edges = append(edges, privatechat.EdgeChat)
	}
	if m.cleareduser1 {
		edges = append(edges, privatechat.EdgeUser1)
	}
	if m.cleareduser2 {
		edges = append(edges, privatechat.EdgeUser2)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrivateChatMutation) EdgeCleared(name string) bool {
	switch name {
	case privatechat.EdgeChat:
		return m.clearedchat
	case privatechat.EdgeUser1:
		return m.cleareduser1
	case privatechat.EdgeUser2:
		return m.cleareduser2
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrivateChatMutation) ClearEdge(name string) error {
	switch name {
	case privatechat.EdgeChat:
		m.ClearChat()
		return nil
	case privatechat.EdgeUser1:
		m.ClearUser1()
		return nil
	case privatechat.EdgeUser2:
		m.ClearUser2()
		return nil
	}
	return fmt.Errorf("unknown PrivateChat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrivateChatMutation) ResetEdge(name string) error {
	switch name {
	case privatechat.EdgeChat:
		m.ResetChat()
		return nil
	case privatechat.EdgeUser1:
		m.ResetUser1()
		return nil
	case privatechat.EdgeUser2:
		m.ResetUser2()
		return nil
	}
	return fmt.Errorf("unknown PrivateChat edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	created_at                    *time.Time
	updated_at                    *time.Time
	email                         *string
	password_hash                 *string
	full_name                     *string
	bio                           *string
	avatar_file_name              *string
	is_online                     *bool
	last_seen_at                  *time.Time
	clearedFields                 map[string]struct{}
	identities                    map[int]struct{}
	removedidentities             map[int]struct{}
	clearedidentities             bool
	sent_messages                 map[int]struct{}
	removedsent_messages          map[int]struct{}
	clearedsent_messages          bool
	created_groups                map[int]struct{}
	removedcreated_groups         map[int]struct{}
	clearedcreated_groups         bool
	group_memberships             map[int]struct{}
	removedgroup_memberships      map[int]struct{}
	clearedgroup_memberships      bool
	private_chats_as_user1        map[int]struct{}
	removedprivate_chats_as_user1 map[int]struct{}
	clearedprivate_chats_as_user1 bool
	private_chats_as_user2        map[int]struct{}
	removedprivate_chats_as_user2 map[int]struct{}
	clearedprivate_chats_as_user2 bool
	done                          bool
	oldValue                      func(context.Context) (*User, error)
	predicates                    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetAvatarFileName sets the "avatar_file_name" field.
func (m *UserMutation) SetAvatarFileName(s string) {
	m.avatar_file_name = &s
}

// AvatarFileName returns the value of the "avatar_file_name" field in the mutation.
func (m *UserMutation) AvatarFileName() (r string, exists bool) {
	v := m.avatar_file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarFileName returns the old "avatar_file_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarFileName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarFileName: %w", err)
	}
	return oldValue.AvatarFileName, nil
}

// ClearAvatarFileName clears the value of the "avatar_file_name" field.
func (m *UserMutation) ClearAvatarFileName() {
	m.avatar_file_name = nil
	m.clearedFields[user.FieldAvatarFileName] = struct{}{}
}

// AvatarFileNameCleared returns if the "avatar_file_name" field was cleared in this mutation.
func (m *UserMutation) AvatarFileNameCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarFileName]
	return ok
}

// ResetAvatarFileName resets all changes to the "avatar_file_name" field.
func (m *UserMutation) ResetAvatarFileName() {
	m.avatar_file_name = nil
	delete(m.clearedFields, user.FieldAvatarFileName)
}

// SetIsOnline sets the "is_online" field.
func (m *UserMutation) SetIsOnline(b bool) {
	m.is_online = &b
}

// IsOnline returns the value of the "is_online" field in the mutation.
func (m *UserMutation) IsOnline() (r bool, exists bool) {
	v := m.is_online
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnline returns the old "is_online" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnline: %w", err)
	}
	return oldValue.IsOnline, nil
}

// ResetIsOnline resets all changes to the "is_online" field.
func (m *UserMutation) ResetIsOnline() {
	m.is_online = nil
}

// SetLastSeenAt sets the "last_seen_at" field.
func (m *UserMutation) SetLastSeenAt(t time.Time) {
	m.last_seen_at = &t
}

// LastSeenAt returns the value of the "last_seen_at" field in the mutation.
func (m *UserMutation) LastSeenAt() (r time.Time, exists bool) {
	v := m.last_seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSeenAt returns the old "last_seen_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastSeenAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSeenAt: %w", err)
	}
	return oldValue.LastSeenAt, nil
}

// ClearLastSeenAt clears the value of the "last_seen_at" field.
func (m *UserMutation) ClearLastSeenAt() {
	m.last_seen_at = nil
	m.clearedFields[user.FieldLastSeenAt] = struct{}{}
}

// LastSeenAtCleared returns if the "last_seen_at" field was cleared in this mutation.
func (m *UserMutation) LastSeenAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastSeenAt]
	return ok
}

// ResetLastSeenAt resets all changes to the "last_seen_at" field.
func (m *UserMutation) ResetLastSeenAt() {
	m.last_seen_at = nil
	delete(m.clearedFields, user.FieldLastSeenAt)
}

// AddIdentityIDs adds the "identities" edge to the UserIdentity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...int) {
	if m.identities == nil {
		m.identities = make(map[int]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the UserIdentity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the UserIdentity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the UserIdentity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...int) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the UserIdentity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []int) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []int) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddSentMessageIDs adds the "sent_messages" edge to the Message entity by ids.
func (m *UserMutation) AddSentMessageIDs(ids ...int) {
	if m.sent_messages == nil {
		m.sent_messages = make(map[int]struct{})
	}
	for i := range ids {
		m.sent_messages[ids[i]] = struct{}{}
	}
}

// ClearSentMessages clears the "sent_messages" edge to the Message entity.
func (m *UserMutation) ClearSentMessages() {
	m.clearedsent_messages = true
}

// SentMessagesCleared reports if the "sent_messages" edge to the Message entity was cleared.
func (m *UserMutation) SentMessagesCleared() bool {
	return m.clearedsent_messages
}

// RemoveSentMessageIDs removes the "sent_messages" edge to the Message entity by IDs.
func (m *UserMutation) RemoveSentMessageIDs(ids ...int) {
	if m.removedsent_messages == nil {
		m.removedsent_messages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sent_messages, ids[i])
		m.removedsent_messages[ids[i]] = struct{}{}
	}
}

// RemovedSentMessages returns the removed IDs of the "sent_messages" edge to the Message entity.
func (m *UserMutation) RemovedSentMessagesIDs() (ids []int) {
	for id := range m.removedsent_messages {
		ids = append(ids, id)
	}
	return
}

// SentMessagesIDs returns the "sent_messages" edge IDs in the mutation.
func (m *UserMutation) SentMessagesIDs() (ids []int) {
	for id := range m.sent_messages {
		ids = append(ids, id)
	}
	return
}

// ResetSentMessages resets all changes to the "sent_messages" edge.
func (m *UserMutation) ResetSentMessages() {
	m.sent_messages = nil
	m.clearedsent_messages = false
	m.removedsent_messages = nil
}

// AddCreatedGroupIDs adds the "created_groups" edge to the GroupChat entity by ids.
func (m *UserMutation) AddCreatedGroupIDs(ids ...int) {
	if m.created_groups == nil {
		m.created_groups = make(map[int]struct{})
	}
	for i := range ids {
		m.created_groups[ids[i]] = struct{}{}
	}
}

// ClearCreatedGroups clears the "created_groups" edge to the GroupChat entity.
func (m *UserMutation) ClearCreatedGroups() {
	m.clearedcreated_groups = true
}

// CreatedGroupsCleared reports if the "created_groups" edge to the GroupChat entity was cleared.
func (m *UserMutation) CreatedGroupsCleared() bool {
	return m.clearedcreated_groups
}

// RemoveCreatedGroupIDs removes the "created_groups" edge to the GroupChat entity by IDs.
func (m *UserMutation) RemoveCreatedGroupIDs(ids ...int) {
	if m.removedcreated_groups == nil {
		m.removedcreated_groups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_groups, ids[i])
		m.removedcreated_groups[ids[i]] = struct{}{}
	}
}

// RemovedCreatedGroups returns the removed IDs of the "created_groups" edge to the GroupChat entity.
func (m *UserMutation) RemovedCreatedGroupsIDs() (ids []int) {
	for id := range m.removedcreated_groups {
		ids = append(ids, id)
	}
	return
}

// CreatedGroupsIDs returns the "created_groups" edge IDs in the mutation.
func (m *UserMutation) CreatedGroupsIDs() (ids []int) {
	for id := range m.created_groups {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedGroups resets all changes to the "created_groups" edge.
func (m *UserMutation) ResetCreatedGroups() {
	m.created_groups = nil
	m.clearedcreated_groups = false
	m.removedcreated_groups = nil
}

// AddGroupMembershipIDs adds the "group_memberships" edge to the GroupMember entity by ids.
func (m *UserMutation) AddGroupMembershipIDs(ids ...int) {
	if m.group_memberships == nil {
		m.group_memberships = make(map[int]struct{})
	}
	for i := range ids {
		m.group_memberships[ids[i]] = struct{}{}
	}
}

// ClearGroupMemberships clears the "group_memberships" edge to the GroupMember entity.
func (m *UserMutation) ClearGroupMemberships() {
	m.clearedgroup_memberships = true
}

// GroupMembershipsCleared reports if the "group_memberships" edge to the GroupMember entity was cleared.
func (m *UserMutation) GroupMembershipsCleared() bool {
	return m.clearedgroup_memberships
}

// RemoveGroupMembershipIDs removes the "group_memberships" edge to the GroupMember entity by IDs.
func (m *UserMutation) RemoveGroupMembershipIDs(ids ...int) {
	if m.removedgroup_memberships == nil {
		m.removedgroup_memberships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.group_memberships, ids[i])
		m.removedgroup_memberships[ids[i]] = struct{}{}
	}
}

// RemovedGroupMemberships returns the removed IDs of the "group_memberships" edge to the GroupMember entity.
func (m *UserMutation) RemovedGroupMembershipsIDs() (ids []int) {
	for id := range m.removedgroup_memberships {
		ids = append(ids, id)
	}
	return
}

// GroupMembershipsIDs returns the "group_memberships" edge IDs in the mutation.
func (m *UserMutation) GroupMembershipsIDs() (ids []int) {
	for id := range m.group_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetGroupMemberships resets all changes to the "group_memberships" edge.
func (m *UserMutation) ResetGroupMemberships() {
	m.group_memberships = nil
	m.clearedgroup_memberships = false
	m.removedgroup_memberships = nil
}

// AddPrivateChatsAsUser1IDs adds the "private_chats_as_user1" edge to the PrivateChat entity by ids.
func (m *UserMutation) AddPrivateChatsAsUser1IDs(ids ...int) {
	if m.private_chats_as_user1 == nil {
		m.private_chats_as_user1 = make(map[int]struct{})
	}
	for i := range ids {
		m.private_chats_as_user1[ids[i]] = struct{}{}
	}
}

// ClearPrivateChatsAsUser1 clears the "private_chats_as_user1" edge to the PrivateChat entity.
func (m *UserMutation) ClearPrivateChatsAsUser1() {
	m.clearedprivate_chats_as_user1 = true
}

// PrivateChatsAsUser1Cleared reports if the "private_chats_as_user1" edge to the PrivateChat entity was cleared.
func (m *UserMutation) PrivateChatsAsUser1Cleared() bool {
	return m.clearedprivate_chats_as_user1
}

// RemovePrivateChatsAsUser1IDs removes the "private_chats_as_user1" edge to the PrivateChat entity by IDs.
func (m *UserMutation) RemovePrivateChatsAsUser1IDs(ids ...int) {
	if m.removedprivate_chats_as_user1 == nil {
		m.removedprivate_chats_as_user1 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.private_chats_as_user1, ids[i])
		m.removedprivate_chats_as_user1[ids[i]] = struct{}{}
	}
}

// RemovedPrivateChatsAsUser1 returns the removed IDs of the "private_chats_as_user1" edge to the PrivateChat entity.
func (m *UserMutation) RemovedPrivateChatsAsUser1IDs() (ids []int) {
	for id := range m.removedprivate_chats_as_user1 {
		ids = append(ids, id)
	}
	return
}

// PrivateChatsAsUser1IDs returns the "private_chats_as_user1" edge IDs in the mutation.
func (m *UserMutation) PrivateChatsAsUser1IDs() (ids []int) {
	for id := range m.private_chats_as_user1 {
		ids = append(ids, id)
	}
	return
}

// ResetPrivateChatsAsUser1 resets all changes to the "private_chats_as_user1" edge.
func (m *UserMutation) ResetPrivateChatsAsUser1() {
	m.private_chats_as_user1 = nil
	m.clearedprivate_chats_as_user1 = false
	m.removedprivate_chats_as_user1 = nil
}

// AddPrivateChatsAsUser2IDs adds the "private_chats_as_user2" edge to the PrivateChat entity by ids.
func (m *UserMutation) AddPrivateChatsAsUser2IDs(ids ...int) {
	if m.private_chats_as_user2 == nil {
		m.private_chats_as_user2 = make(map[int]struct{})
	}
	for i := range ids {
		m.private_chats_as_user2[ids[i]] = struct{}{}
	}
}

// ClearPrivateChatsAsUser2 clears the "private_chats_as_user2" edge to the PrivateChat entity.
func (m *UserMutation) ClearPrivateChatsAsUser2() {
	m.clearedprivate_chats_as_user2 = true
}

// PrivateChatsAsUser2Cleared reports if the "private_chats_as_user2" edge to the PrivateChat entity was cleared.
func (m *UserMutation) PrivateChatsAsUser2Cleared() bool {
	return m.clearedprivate_chats_as_user2
}

// RemovePrivateChatsAsUser2IDs removes the "private_chats_as_user2" edge to the PrivateChat entity by IDs.
func (m *UserMutation) RemovePrivateChatsAsUser2IDs(ids ...int) {
	if m.removedprivate_chats_as_user2 == nil {
		m.removedprivate_chats_as_user2 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.private_chats_as_user2, ids[i])
		m.removedprivate_chats_as_user2[ids[i]] = struct{}{}
	}
}

// RemovedPrivateChatsAsUser2 returns the removed IDs of the "private_chats_as_user2" edge to the PrivateChat entity.
func (m *UserMutation) RemovedPrivateChatsAsUser2IDs() (ids []int) {
	for id := range m.removedprivate_chats_as_user2 {
		ids = append(ids, id)
	}
	return
}

// PrivateChatsAsUser2IDs returns the "private_chats_as_user2" edge IDs in the mutation.
func (m *UserMutation) PrivateChatsAsUser2IDs() (ids []int) {
	for id := range m.private_chats_as_user2 {
		ids = append(ids, id)
	}
	return
}

// ResetPrivateChatsAsUser2 resets all changes to the "private_chats_as_user2" edge.
func (m *UserMutation) ResetPrivateChatsAsUser2() {
	m.private_chats_as_user2 = nil
	m.clearedprivate_chats_as_user2 = false
	m.removedprivate_chats_as_user2 = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.avatar_file_name != nil {
		fields = append(fields, user.FieldAvatarFileName)
	}
	if m.is_online != nil {
		fields = append(fields, user.FieldIsOnline)
	}
	if m.last_seen_at != nil {
		fields = append(fields, user.FieldLastSeenAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldBio:
		return m.Bio()
	case user.FieldAvatarFileName:
		return m.AvatarFileName()
	case user.FieldIsOnline:
		return m.IsOnline()
	case user.FieldLastSeenAt:
		return m.LastSeenAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldAvatarFileName:
		return m.OldAvatarFileName(ctx)
	case user.FieldIsOnline:
		return m.OldIsOnline(ctx)
	case user.FieldLastSeenAt:
		return m.OldLastSeenAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldAvatarFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarFileName(v)
		return nil
	case user.FieldIsOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnline(v)
		return nil
	case user.FieldLastSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSeenAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldAvatarFileName) {
		fields = append(fields, user.FieldAvatarFileName)
	}
	if m.FieldCleared(user.FieldLastSeenAt) {
		fields = append(fields, user.FieldLastSeenAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldAvatarFileName:
		m.ClearAvatarFileName()
		return nil
	case user.FieldLastSeenAt:
		m.ClearLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldAvatarFileName:
		m.ResetAvatarFileName()
		return nil
	case user.FieldIsOnline:
		m.ResetIsOnline()
		return nil
	case user.FieldLastSeenAt:
		m.ResetLastSeenAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.sent_messages != nil {
		edges = append(edges, user.EdgeSentMessages)
	}
	if m.created_groups != nil {
		edges = append(edges, user.EdgeCreatedGroups)
	}
	if m.group_memberships != nil {
		edges = append(edges, user.EdgeGroupMemberships)
	}
	if m.private_chats_as_user1 != nil {
		edges = append(edges, user.EdgePrivateChatsAsUser1)
	}
	if m.private_chats_as_user2 != nil {
		edges = append(edges, user.EdgePrivateChatsAsUser2)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentMessages:
		ids := make([]ent.Value, 0, len(m.sent_messages))
		for id := range m.sent_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedGroups:
		ids := make([]ent.Value, 0, len(m.created_groups))
		for id := range m.created_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroupMemberships:
		ids := make([]ent.Value, 0, len(m.group_memberships))
		for id := range m.group_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrivateChatsAsUser1:
		ids := make([]ent.Value, 0, len(m.private_chats_as_user1))
		for id := range m.private_chats_as_user1 {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrivateChatsAsUser2:
		ids := make([]ent.Value, 0, len(m.private_chats_as_user2))
		for id := range m.private_chats_as_user2 {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedsent_messages != nil {
		edges = append(edges, user.EdgeSentMessages)
	}
	if m.removedcreated_groups != nil {
		edges = append(edges, user.EdgeCreatedGroups)
	}
	if m.removedgroup_memberships != nil {
		edges = append(edges, user.EdgeGroupMemberships)
	}
	if m.removedprivate_chats_as_user1 != nil {
		edges = append(edges, user.EdgePrivateChatsAsUser1)
	}
	if m.removedprivate_chats_as_user2 != nil {
		edges = append(edges, user.EdgePrivateChatsAsUser2)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentMessages:
		ids := make([]ent.Value, 0, len(m.removedsent_messages))
		for id := range m.removedsent_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedGroups:
		ids := make([]ent.Value, 0, len(m.removedcreated_groups))
		for id := range m.removedcreated_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroupMemberships:
		ids := make([]ent.Value, 0, len(m.removedgroup_memberships))
		for id := range m.removedgroup_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrivateChatsAsUser1:
		ids := make([]ent.Value, 0, len(m.removedprivate_chats_as_user1))
		for id := range m.removedprivate_chats_as_user1 {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePrivateChatsAsUser2:
		ids := make([]ent.Value, 0, len(m.removedprivate_chats_as_user2))
		for id := range m.removedprivate_chats_as_user2 {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedsent_messages {
		edges = append(edges, user.EdgeSentMessages)
	}
	if m.clearedcreated_groups {
		edges = append(edges, user.EdgeCreatedGroups)
	}
	if m.clearedgroup_memberships {
		edges = append(edges, user.EdgeGroupMemberships)
	}
	if m.clearedprivate_chats_as_user1 {
		edges = append(edges, user.EdgePrivateChatsAsUser1)
	}
	if m.clearedprivate_chats_as_user2 {
		edges = append(edges, user.EdgePrivateChatsAsUser2)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeSentMessages:
		return m.clearedsent_messages
	case user.EdgeCreatedGroups:
		return m.clearedcreated_groups
	case user.EdgeGroupMemberships:
		return m.clearedgroup_memberships
	case user.EdgePrivateChatsAsUser1:
		return m.clearedprivate_chats_as_user1
	case user.EdgePrivateChatsAsUser2:
		return m.clearedprivate_chats_as_user2
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeSentMessages:
		m.ResetSentMessages()
		return nil
	case user.EdgeCreatedGroups:
		m.ResetCreatedGroups()
		return nil
	case user.EdgeGroupMemberships:
		m.ResetGroupMemberships()
		return nil
	case user.EdgePrivateChatsAsUser1:
		m.ResetPrivateChatsAsUser1()
		return nil
	case user.EdgePrivateChatsAsUser2:
		m.ResetPrivateChatsAsUser2()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserIdentityMutation represents an operation that mutates the UserIdentity nodes in the graph.
type UserIdentityMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	provider       *useridentity.Provider
	provider_id    *string
	provider_email *string
	clearedFields  map[string]struct{}
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserIdentity, error)
	predicates     []predicate.UserIdentity
}

var _ ent.Mutation = (*UserIdentityMutation)(nil)

// useridentityOption allows management of the mutation configuration using functional options.
type useridentityOption func(*UserIdentityMutation)

// newUserIdentityMutation creates new mutation for the UserIdentity entity.
func newUserIdentityMutation(c config, op Op, opts ...useridentityOption) *UserIdentityMutation {
	m := &UserIdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserIdentityID sets the ID field of the mutation.
func withUserIdentityID(id int) useridentityOption {
	return func(m *UserIdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserIdentity
		)
		m.oldValue = func(ctx context.Context) (*UserIdentity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserIdentity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserIdentity sets the old UserIdentity of the mutation.
func withUserIdentity(node *UserIdentity) useridentityOption {
	return func(m *UserIdentityMutation) {
		m.oldValue = func(context.Context) (*UserIdentity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserIdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserIdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserIdentityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserIdentityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserIdentity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserIdentityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserIdentityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserIdentityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserIdentityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserIdentityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserIdentityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserIdentityMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserIdentityMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserIdentityMutation) ResetUserID() {
	m.user = nil
}

// SetProvider sets the "provider" field.
func (m *UserIdentityMutation) SetProvider(u useridentity.Provider) {
	m.provider = &u
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserIdentityMutation) Provider() (r useridentity.Provider, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProvider(ctx context.Context) (v useridentity.Provider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserIdentityMutation) ResetProvider() {
	m.provider = nil
}

// SetProviderID sets the "provider_id" field.
func (m *UserIdentityMutation) SetProviderID(s string) {
	m.provider_id = &s
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *UserIdentityMutation) ProviderID() (r string, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProviderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *UserIdentityMutation) ResetProviderID() {
	m.provider_id = nil
}

// SetProviderEmail sets the "provider_email" field.
func (m *UserIdentityMutation) SetProviderEmail(s string) {
	m.provider_email = &s
}

// ProviderEmail returns the value of the "provider_email" field in the mutation.
func (m *UserIdentityMutation) ProviderEmail() (r string, exists bool) {
	v := m.provider_email
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderEmail returns the old "provider_email" field's value of the UserIdentity entity.
// If the UserIdentity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserIdentityMutation) OldProviderEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderEmail: %w", err)
	}
	return oldValue.ProviderEmail, nil
}

// ClearProviderEmail clears the value of the "provider_email" field.
func (m *UserIdentityMutation) ClearProviderEmail() {
	m.provider_email = nil
	m.clearedFields[useridentity.FieldProviderEmail] = struct{}{}
}

// ProviderEmailCleared returns if the "provider_email" field was cleared in this mutation.
func (m *UserIdentityMutation) ProviderEmailCleared() bool {
	_, ok := m.clearedFields[useridentity.FieldProviderEmail]
	return ok
}

// ResetProviderEmail resets all changes to the "provider_email" field.
func (m *UserIdentityMutation) ResetProviderEmail() {
	m.provider_email = nil
	delete(m.clearedFields, useridentity.FieldProviderEmail)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserIdentityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[useridentity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserIdentityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserIdentityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserIdentityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserIdentityMutation builder.
func (m *UserIdentityMutation) Where(ps ...predicate.UserIdentity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserIdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserIdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserIdentity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserIdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserIdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserIdentity).
func (m *UserIdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserIdentityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, useridentity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, useridentity.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, useridentity.FieldUserID)
	}
	if m.provider != nil {
		fields = append(fields, useridentity.FieldProvider)
	}
	if m.provider_id != nil {
		fields = append(fields, useridentity.FieldProviderID)
	}
	if m.provider_email != nil {
		fields = append(fields, useridentity.FieldProviderEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserIdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useridentity.FieldCreatedAt:
		return m.CreatedAt()
	case useridentity.FieldUpdatedAt:
		return m.UpdatedAt()
	case useridentity.FieldUserID:
		return m.UserID()
	case useridentity.FieldProvider:
		return m.Provider()
	case useridentity.FieldProviderID:
		return m.ProviderID()
	case useridentity.FieldProviderEmail:
		return m.ProviderEmail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserIdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useridentity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useridentity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useridentity.FieldUserID:
		return m.OldUserID(ctx)
	case useridentity.FieldProvider:
		return m.OldProvider(ctx)
	case useridentity.FieldProviderID:
		return m.OldProviderID(ctx)
	case useridentity.FieldProviderEmail:
		return m.OldProviderEmail(ctx)
	}
	return nil, fmt.Errorf("unknown UserIdentity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useridentity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useridentity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useridentity.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useridentity.FieldProvider:
		v, ok := value.(useridentity.Provider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case useridentity.FieldProviderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case useridentity.FieldProviderEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderEmail(v)
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserIdentityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserIdentityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserIdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserIdentity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserIdentityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useridentity.FieldProviderEmail) {
		fields = append(fields, useridentity.FieldProviderEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserIdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserIdentityMutation) ClearField(name string) error {
	switch name {
	case useridentity.FieldProviderEmail:
		m.ClearProviderEmail()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserIdentityMutation) ResetField(name string) error {
	switch name {
	case useridentity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useridentity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useridentity.FieldUserID:
		m.ResetUserID()
		return nil
	case useridentity.FieldProvider:
		m.ResetProvider()
		return nil
	case useridentity.FieldProviderID:
		m.ResetProviderID()
		return nil
	case useridentity.FieldProviderEmail:
		m.ResetProviderEmail()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserIdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserIdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useridentity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserIdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserIdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserIdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useridentity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserIdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case useridentity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserIdentityMutation) ClearEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserIdentityMutation) ResetEdge(name string) error {
	switch name {
	case useridentity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserIdentity edge %s", name)
}
