// Code generated by ent, DO NOT EDIT.

package ent

import (
	"AtoiTalkAPI/ent/media"
	"AtoiTalkAPI/ent/user"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

// User is the model entity for the User schema.
type User struct {
	config `json:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Email holds the value of the "email" field.
	Email *string `json:"email,omitempty"`
	// Username holds the value of the "username" field.
	Username *string `json:"username,omitempty"`
	// PasswordHash holds the value of the "password_hash" field.
	PasswordHash *string `json:"-"`
	// FullName holds the value of the "full_name" field.
	FullName *string `json:"full_name,omitempty"`
	// Bio holds the value of the "bio" field.
	Bio *string `json:"bio,omitempty"`
	// AvatarID holds the value of the "avatar_id" field.
	AvatarID *uuid.UUID `json:"avatar_id,omitempty"`
	// LastSeenAt holds the value of the "last_seen_at" field.
	LastSeenAt *time.Time `json:"last_seen_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// Role holds the value of the "role" field.
	Role user.Role `json:"role,omitempty"`
	// IsBanned holds the value of the "is_banned" field.
	IsBanned bool `json:"is_banned,omitempty"`
	// BannedUntil holds the value of the "banned_until" field.
	BannedUntil *time.Time `json:"banned_until,omitempty"`
	// BanReason holds the value of the "ban_reason" field.
	BanReason *string `json:"ban_reason,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the UserQuery when eager-loading is set.
	Edges        UserEdges `json:"edges"`
	selectValues sql.SelectValues
}

// UserEdges holds the relations/edges for other nodes in the graph.
type UserEdges struct {
	// Avatar holds the value of the avatar edge.
	Avatar *Media `json:"avatar,omitempty"`
	// Identities holds the value of the identities edge.
	Identities []*UserIdentity `json:"identities,omitempty"`
	// SentMessages holds the value of the sent_messages edge.
	SentMessages []*Message `json:"sent_messages,omitempty"`
	// CreatedGroups holds the value of the created_groups edge.
	CreatedGroups []*GroupChat `json:"created_groups,omitempty"`
	// GroupMemberships holds the value of the group_memberships edge.
	GroupMemberships []*GroupMember `json:"group_memberships,omitempty"`
	// PrivateChatsAsUser1 holds the value of the private_chats_as_user1 edge.
	PrivateChatsAsUser1 []*PrivateChat `json:"private_chats_as_user1,omitempty"`
	// PrivateChatsAsUser2 holds the value of the private_chats_as_user2 edge.
	PrivateChatsAsUser2 []*PrivateChat `json:"private_chats_as_user2,omitempty"`
	// UploadedMedia holds the value of the uploaded_media edge.
	UploadedMedia []*Media `json:"uploaded_media,omitempty"`
	// BlockedUsersRel holds the value of the blocked_users_rel edge.
	BlockedUsersRel []*UserBlock `json:"blocked_users_rel,omitempty"`
	// BlockedByRel holds the value of the blocked_by_rel edge.
	BlockedByRel []*UserBlock `json:"blocked_by_rel,omitempty"`
	// ReportsMade holds the value of the reports_made edge.
	ReportsMade []*Report `json:"reports_made,omitempty"`
	// ReportsReceived holds the value of the reports_received edge.
	ReportsReceived []*Report `json:"reports_received,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [12]bool
}

// AvatarOrErr returns the Avatar value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e UserEdges) AvatarOrErr() (*Media, error) {
	if e.Avatar != nil {
		return e.Avatar, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: media.Label}
	}
	return nil, &NotLoadedError{edge: "avatar"}
}

// IdentitiesOrErr returns the Identities value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) IdentitiesOrErr() ([]*UserIdentity, error) {
	if e.loadedTypes[1] {
		return e.Identities, nil
	}
	return nil, &NotLoadedError{edge: "identities"}
}

// SentMessagesOrErr returns the SentMessages value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) SentMessagesOrErr() ([]*Message, error) {
	if e.loadedTypes[2] {
		return e.SentMessages, nil
	}
	return nil, &NotLoadedError{edge: "sent_messages"}
}

// CreatedGroupsOrErr returns the CreatedGroups value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) CreatedGroupsOrErr() ([]*GroupChat, error) {
	if e.loadedTypes[3] {
		return e.CreatedGroups, nil
	}
	return nil, &NotLoadedError{edge: "created_groups"}
}

// GroupMembershipsOrErr returns the GroupMemberships value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) GroupMembershipsOrErr() ([]*GroupMember, error) {
	if e.loadedTypes[4] {
		return e.GroupMemberships, nil
	}
	return nil, &NotLoadedError{edge: "group_memberships"}
}

// PrivateChatsAsUser1OrErr returns the PrivateChatsAsUser1 value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) PrivateChatsAsUser1OrErr() ([]*PrivateChat, error) {
	if e.loadedTypes[5] {
		return e.PrivateChatsAsUser1, nil
	}
	return nil, &NotLoadedError{edge: "private_chats_as_user1"}
}

// PrivateChatsAsUser2OrErr returns the PrivateChatsAsUser2 value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) PrivateChatsAsUser2OrErr() ([]*PrivateChat, error) {
	if e.loadedTypes[6] {
		return e.PrivateChatsAsUser2, nil
	}
	return nil, &NotLoadedError{edge: "private_chats_as_user2"}
}

// UploadedMediaOrErr returns the UploadedMedia value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) UploadedMediaOrErr() ([]*Media, error) {
	if e.loadedTypes[7] {
		return e.UploadedMedia, nil
	}
	return nil, &NotLoadedError{edge: "uploaded_media"}
}

// BlockedUsersRelOrErr returns the BlockedUsersRel value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) BlockedUsersRelOrErr() ([]*UserBlock, error) {
	if e.loadedTypes[8] {
		return e.BlockedUsersRel, nil
	}
	return nil, &NotLoadedError{edge: "blocked_users_rel"}
}

// BlockedByRelOrErr returns the BlockedByRel value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) BlockedByRelOrErr() ([]*UserBlock, error) {
	if e.loadedTypes[9] {
		return e.BlockedByRel, nil
	}
	return nil, &NotLoadedError{edge: "blocked_by_rel"}
}

// ReportsMadeOrErr returns the ReportsMade value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) ReportsMadeOrErr() ([]*Report, error) {
	if e.loadedTypes[10] {
		return e.ReportsMade, nil
	}
	return nil, &NotLoadedError{edge: "reports_made"}
}

// ReportsReceivedOrErr returns the ReportsReceived value or an error if the edge
// was not loaded in eager-loading.
func (e UserEdges) ReportsReceivedOrErr() ([]*Report, error) {
	if e.loadedTypes[11] {
		return e.ReportsReceived, nil
	}
	return nil, &NotLoadedError{edge: "reports_received"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*User) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case user.FieldAvatarID:
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case user.FieldIsBanned:
			values[i] = new(sql.NullBool)
		case user.FieldEmail, user.FieldUsername, user.FieldPasswordHash, user.FieldFullName, user.FieldBio, user.FieldRole, user.FieldBanReason:
			values[i] = new(sql.NullString)
		case user.FieldCreatedAt, user.FieldUpdatedAt, user.FieldLastSeenAt, user.FieldDeletedAt, user.FieldBannedUntil:
			values[i] = new(sql.NullTime)
		case user.FieldID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the User fields.
func (_m *User) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case user.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				_m.ID = *value
			}
		case user.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				_m.CreatedAt = value.Time
			}
		case user.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				_m.UpdatedAt = value.Time
			}
		case user.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field email", values[i])
			} else if value.Valid {
				_m.Email = new(string)
				*_m.Email = value.String
			}
		case user.FieldUsername:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field username", values[i])
			} else if value.Valid {
				_m.Username = new(string)
				*_m.Username = value.String
			}
		case user.FieldPasswordHash:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field password_hash", values[i])
			} else if value.Valid {
				_m.PasswordHash = new(string)
				*_m.PasswordHash = value.String
			}
		case user.FieldFullName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field full_name", values[i])
			} else if value.Valid {
				_m.FullName = new(string)
				*_m.FullName = value.String
			}
		case user.FieldBio:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bio", values[i])
			} else if value.Valid {
				_m.Bio = new(string)
				*_m.Bio = value.String
			}
		case user.FieldAvatarID:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field avatar_id", values[i])
			} else if value.Valid {
				_m.AvatarID = new(uuid.UUID)
				*_m.AvatarID = *value.S.(*uuid.UUID)
			}
		case user.FieldLastSeenAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_seen_at", values[i])
			} else if value.Valid {
				_m.LastSeenAt = new(time.Time)
				*_m.LastSeenAt = value.Time
			}
		case user.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				_m.DeletedAt = new(time.Time)
				*_m.DeletedAt = value.Time
			}
		case user.FieldRole:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field role", values[i])
			} else if value.Valid {
				_m.Role = user.Role(value.String)
			}
		case user.FieldIsBanned:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field is_banned", values[i])
			} else if value.Valid {
				_m.IsBanned = value.Bool
			}
		case user.FieldBannedUntil:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field banned_until", values[i])
			} else if value.Valid {
				_m.BannedUntil = new(time.Time)
				*_m.BannedUntil = value.Time
			}
		case user.FieldBanReason:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ban_reason", values[i])
			} else if value.Valid {
				_m.BanReason = new(string)
				*_m.BanReason = value.String
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the User.
// This includes values selected through modifiers, order, etc.
func (_m *User) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// QueryAvatar queries the "avatar" edge of the User entity.
func (_m *User) QueryAvatar() *MediaQuery {
	return NewUserClient(_m.config).QueryAvatar(_m)
}

// QueryIdentities queries the "identities" edge of the User entity.
func (_m *User) QueryIdentities() *UserIdentityQuery {
	return NewUserClient(_m.config).QueryIdentities(_m)
}

// QuerySentMessages queries the "sent_messages" edge of the User entity.
func (_m *User) QuerySentMessages() *MessageQuery {
	return NewUserClient(_m.config).QuerySentMessages(_m)
}

// QueryCreatedGroups queries the "created_groups" edge of the User entity.
func (_m *User) QueryCreatedGroups() *GroupChatQuery {
	return NewUserClient(_m.config).QueryCreatedGroups(_m)
}

// QueryGroupMemberships queries the "group_memberships" edge of the User entity.
func (_m *User) QueryGroupMemberships() *GroupMemberQuery {
	return NewUserClient(_m.config).QueryGroupMemberships(_m)
}

// QueryPrivateChatsAsUser1 queries the "private_chats_as_user1" edge of the User entity.
func (_m *User) QueryPrivateChatsAsUser1() *PrivateChatQuery {
	return NewUserClient(_m.config).QueryPrivateChatsAsUser1(_m)
}

// QueryPrivateChatsAsUser2 queries the "private_chats_as_user2" edge of the User entity.
func (_m *User) QueryPrivateChatsAsUser2() *PrivateChatQuery {
	return NewUserClient(_m.config).QueryPrivateChatsAsUser2(_m)
}

// QueryUploadedMedia queries the "uploaded_media" edge of the User entity.
func (_m *User) QueryUploadedMedia() *MediaQuery {
	return NewUserClient(_m.config).QueryUploadedMedia(_m)
}

// QueryBlockedUsersRel queries the "blocked_users_rel" edge of the User entity.
func (_m *User) QueryBlockedUsersRel() *UserBlockQuery {
	return NewUserClient(_m.config).QueryBlockedUsersRel(_m)
}

// QueryBlockedByRel queries the "blocked_by_rel" edge of the User entity.
func (_m *User) QueryBlockedByRel() *UserBlockQuery {
	return NewUserClient(_m.config).QueryBlockedByRel(_m)
}

// QueryReportsMade queries the "reports_made" edge of the User entity.
func (_m *User) QueryReportsMade() *ReportQuery {
	return NewUserClient(_m.config).QueryReportsMade(_m)
}

// QueryReportsReceived queries the "reports_received" edge of the User entity.
func (_m *User) QueryReportsReceived() *ReportQuery {
	return NewUserClient(_m.config).QueryReportsReceived(_m)
}

// Update returns a builder for updating this User.
// Note that you need to call User.Unwrap() before calling this method if this User
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *User) Update() *UserUpdateOne {
	return NewUserClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the User entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *User) Unwrap() *User {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: User is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *User) String() string {
	var builder strings.Builder
	builder.WriteString("User(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("created_at=")
	builder.WriteString(_m.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(_m.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := _m.Email; v != nil {
		builder.WriteString("email=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.Username; v != nil {
		builder.WriteString("username=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("password_hash=<sensitive>")
	builder.WriteString(", ")
	if v := _m.FullName; v != nil {
		builder.WriteString("full_name=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.Bio; v != nil {
		builder.WriteString("bio=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := _m.AvatarID; v != nil {
		builder.WriteString("avatar_id=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.LastSeenAt; v != nil {
		builder.WriteString("last_seen_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("role=")
	builder.WriteString(fmt.Sprintf("%v", _m.Role))
	builder.WriteString(", ")
	builder.WriteString("is_banned=")
	builder.WriteString(fmt.Sprintf("%v", _m.IsBanned))
	builder.WriteString(", ")
	if v := _m.BannedUntil; v != nil {
		builder.WriteString("banned_until=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.BanReason; v != nil {
		builder.WriteString("ban_reason=")
		builder.WriteString(*v)
	}
	builder.WriteByte(')')
	return builder.String()
}

// Users is a parsable slice of User.
type Users []*User
